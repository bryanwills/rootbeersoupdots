[toplevel]

cfn    = cloudformation
conf   = configure
whoami = sts get-caller-identity

id = sts get-caller-identity \
  --query Account \
  --output text

region = ec2 describe-availability-zones \
  --query 'AvailabilityZones[0].[RegionName]' \
  --output text

regions = ec2 describe-regions \
  --query 'Regions[].RegionName[]' \
  --output text


[command cloudformation]

ls = describe-stacks \
  --query 'Stacks[].[
    StackName,
    StackStatus
  ]'

rm = delete-stack \
  --stack-name

head = describe-stack-events \
  --max-items 10 \
  --query 'StackEvents[].[
    Timestamp,
    ResourceType,
    ResourceStatus
  ]' \
  --stack-name

[command cloudformation wait]

create = stack-create-complete --stack-name
delete = stack-delete-complete --stack-name


[command configure]

ls = list-profiles


[command ec2]

i         = describe-instances
images    = describe-images
img       = describe-images
info      = describe-instances --instance-ids
instances = describe-instances
topo      = describe-instance-topology
t         = describe-instance-types
types     = describe-instance-types

keys = describe-key-pairs \
  --query 'KeyPairs[].[
    KeyName,
    KeyPairId,
    KeyType,
    KeyFingerprint
  ]'

grep = ! _() {
    local type=${1:?expected instance type argument}
    aws ec2 describe-instance-types \
      --filters \
        Name=instance-type,Values=*${type}* \
      --query 'InstanceTypes[].[
        InstanceType,
        VCpuInfo.DefaultVCpus
      ] | sort_by(@, &[1]) | map(&[0], @)'
  }; _

grepall = !_() {
    local type=${1:?expected instance type argument}
    echo "Locating regions with instance types matching ${type} ..."
    for region in $(aws regions); do
      echo $region:
      aws ec2 --region $region grep $type
    done
  }; _

ls = describe-instances \
  --query 'Reservations[].Instances[].[
    InstanceType,
    InstanceId,
    Tags[? Key == `Name`]|[0].Value,
    PublicIpAddress || `-`,
    PrivateIpAddress,
    NetworkInterfaces[? InterfaceType == `efa`]|[0].InterfaceType || `-`,
    Placement.AvailabilityZone,
    State.Name
  ] | sort_by(@, &[0])'

[command ec2 describe-instances]

pcluster = \
  --filters \
    Name=tag-key,Values=parallelcluster:version \
  --query 'Reservations[].Instances[].[
    Tags[? Key == `parallelcluster:cluster-name`]|[0].Value,
    InstanceType,
    Tags[? Key == `parallelcluster:node-type` && Value == `HeadNode`] && `-` || [
      Tags[? Key == `parallelcluster:queue-name`]|[0].Value,
      Tags[? Key == `parallelcluster:compute-resource-name`]|[0].Value
    ].join(`:`,@),
    PublicIpAddress || PrivateIpAddress,
    Placement.AvailabilityZone,
    InstanceId,
    Tags[? Key == `parallelcluster:version`]|[0].Value,
    State.Name
  ] | sort_by(sort_by(@, &[1]), &[0])'

[command ec2 describe-instance-types]

simple = \
  --query 'InstanceTypes[].[
    InstanceType
  ] | sort_by(@, &[0])'

with-efa = --filters \
    Name=network-info.efa-supported,Values=true

efa = \
  with-efa \
  --query 'InstanceTypes[].[
    InstanceType,
    ProcessorInfo.[
      SupportedArchitectures[0],
      Manufacturer
    ].join(`/`,@),
    VCpuInfo.[DefaultVCpus.to_string(@), `vCPUs`].join(`\u0020`,@),
   (FpgaInfo.Fpgas || GpuInfo.Gpus ||
    (InferenceAcceleratorInfo || MediaAcceleratorInfo).Accelerators ||
    NeuronInfo.NeuronDevices
   )[0].[Count] || `-`,
   (FpgaInfo || GpuInfo || InferenceAcceleratorInfo || MediaAcceleratorInfo || NeuronInfo) && [
    (FpgaInfo                 && `FPGA`   ||
     GpuInfo                  && `GPU`    ||
     InferenceAcceleratorInfo && `Inf`    ||
     MediaAcceleratorInfo     && `Media`  ||
     NeuronInfo               && `Neuron`
    ),
    (FpgaInfo.Fpgas || GpuInfo.Gpus ||
     (InferenceAcceleratorInfo || MediaAcceleratorInfo).Accelerators ||
     NeuronInfo.NeuronDevices
    )[0].[(Manufacturer || `AWS`), Name].join(`\u0020`,@)
   ].join(`/`,@) || `-`,
   (FpgaInfo.Fpgas || GpuInfo.Gpus ||
    (InferenceAcceleratorInfo || MediaAcceleratorInfo).Accelerators ||
    NeuronInfo.NeuronDevices
   )[0].[MemoryInfo.SizeInMiB
        .to_string(@)
        .join(`\u0020`, [@, `MiB`])
   ] || `-`,
    NetworkInfo.[
      EfaInfo.MaximumEfaInterfaces
        .to_string(@)
        .join(`\u0020`, [@, `EFA`]),
      NetworkPerformance
    ]
  ] | map(&[], @) | sort_by(@, &[0])'

whereis = !_() {
    local type=${1:?expected instance type}
    for region in $(aws regions); do
      local types="$(aws ec2 types --filters Name=instance-type,Values=*${type}* --query 'InstanceTypes[].[InstanceType]' --region $region --output text)"
      if [[ $types ]]; then
        printf "$region:\t$types\n"
      fi
    done
  }; _


[command ecr]

img      = describe-images
images   = describe-images
password = get-login-password
pw       = get-login-password

ls = describe-repositories \
  --query 'repositories[].[
    repositoryName,
    imageTagMutability,
    repositoryUri
  ]'

repos = describe-repositories \
  --query 'repositories[].[repositoryName]' \
  --output text

tags = describe-images \
  --filter 'tagStatus=TAGGED' \
  --query 'imageDetails[].[
   [imageTags][*].sort(@).join(`\u0020`, @),
    imageDigest,
    imageSizeInBytes.to_string(@).join(`\u0020`, [@, `B`])
  ] | map(&[], @)' \
  --repository-name

[command ecr describe-images]

ls = \
  --query 'imageDetails[].[
    imagePushedAt,
    imageSizeInBytes.to_string(@).join(`\u0020`, [@, `B`]),
    imageDigest,
    imageTags && [imageTags][*].sort(@).join(`\u0020`, @) || ``
  ] | map(&[], @) | sort_by(@, &[0])' \
  --repository-name

[command ecr-public]

registry = describe-registries \
  --query 'registries[].[registryUri]' \
  --region us-east-1 \
  --output text

login-docker = !_() {
    aws ecr-public get-login-password --region us-east-1 |
      docker login --username AWS --password-stdin $(aws ecr-public registry)
  }; _
